# Local Secret Management in Visual Studio for .NET Solutions

This note documents how local secret management works for .NET applications in Visual Studio, with an emphasis on multi-project, multi-solution setups and consistent behavior across a development team.
## Goals

- Keep sensitive values (such as connection strings, API keys, and passwords) **out** of source control.  
- Provide a consistent configuration experience for all developers working on the same solution.  
- Support multiple solutions and multiple application projects (e.g. console, Web API, Blazor) within each solution. 

> Although this document references Visual Studio, the underlying User Secrets mechanism is part of the .NET SDK and works the same across editors and platforms. For example, this works in dotnet user-secrets CLI, Rider, and VS Code as well. 

## Core Concepts

- **User Secrets** is a .NET feature that stores secrets in a JSON file under the current user’s profile, outside the project folder and Git repository.
- User Secrets are intended for **development** only; production secrets should live in a proper secrets store (Key Vault, AWS Secrets Manager, etc.), not in User Secrets.
- Each .NET application project can specify a `UserSecretsId` in its `.csproj` file; this ID tells .NET where to find the corresponding `secrets.json` file for that project.  
- The `UserSecretsId` itself is not sensitive; it is safe and expected to commit it to source control.

## How User Secrets Are Stored

- When **Manage User Secrets** is used for a project in Visual Studio, a `<UserSecretsId>...</UserSecretsId>` element is added to that project’s `.csproj`.  
- .NET uses this ID as a lookup key into a per-user directory (for example, under the user profile) where `secrets.json` is stored.  
- Because `secrets.json` lives outside the solution folder, it is not tracked by Git and will not be pushed to GitHub.  

#### Example of secrets.json location

**Windows:**  
`%APPDATA%\Microsoft\UserSecrets\<UserSecretsId>\secrets.json`

**macOS/Linux:**  
`~/.microsoft/usersecrets/<UserSecretsId>/secrets.json`

#### Example `.csproj` fragment:

```xml
<PropertyGroup>
  <TargetFramework>net8.0</TargetFramework>
  <UserSecretsId>8084c8e7-0000-0000-0000-c26798dc28d1</UserSecretsId>
</PropertyGroup>
```

## How Configuration Resolution Works

- The application uses the standard .NET configuration system, reading from `appsettings.json`, `appsettings.{Environment}.json`, User Secrets, and environment variables.
- For typical ASP.NET Core or modern .NET app templates, User Secrets are automatically included in the configuration pipeline when running in the Development environment.
- Keys in `secrets.json` are merged into the configuration and override matching keys from `appsettings.json`, which allows sensitive values to be supplied only via User Secrets.

Example pattern in code:

```csharp
builder.Configuration
    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional: true)
    .AddUserSecrets<Program>(optional: true, reloadOnChange: true)
    .AddEnvironmentVariables();
```

## Relationship Between Solutions, Projects, and UserSecretsId

- Each application project (e.g. console, Web API) can have its own `UserSecretsId`, which maps to its own `secrets.json`.  Only _application_ projects (those that produce an executable) should define a `UserSecretsId`. Class libraries should not. They inherit configuration from the app that loads them.
- Multiple solutions can coexist, each containing several applications; using distinct `UserSecretsId` values avoids collisions when different solutions have the same logical key names (for example, `ConnectionStrings:Default`).
- For a given project, all developers share the same `UserSecretsId` (since it lives in the committed `.csproj`), but each developer has their own local `secrets.json` with their personal or environment-specific values.

This pattern supports:

- **Different secrets per solution**: Each app in each solution has its own `UserSecretsId` and `secrets.json`.
- **Same behavior for all developers on the same solution**: Everyone uses the same project file, same `UserSecretsId`, and same configuration key names; only the secret values differ per developer.

## What Should and Should Not Be Committed

- **Commit**:
    - The `.csproj` files, including the `<UserSecretsId>` entries.
    - Any non-sensitive configuration with default or placeholder values in `appsettings.json`.
    - Documentation describing the required keys (for example, `docs/configuration.md` and example files with fake values).
- **Do not commit**:
    - Any real secrets in `appsettings.json` or other tracked files.
    - The actual `secrets.json` files generated by User Secrets (these stay under the developer’s user profile).


## Design Trade-offs and Rationale

- Using a committed `UserSecretsId` for each app project ensures that every developer works with the same configuration shape, which simplifies onboarding, automation, and documentation.
- Storing actual secret values only in local `secrets.json` files preserves security and prevents accidental leaks in Git history.
- Having different `UserSecretsId` values across solutions allows reusing key names (like `ConnectionStrings:Default`) without cross-solution interference, making it easier to maintain multiple monolithic solutions side by side.